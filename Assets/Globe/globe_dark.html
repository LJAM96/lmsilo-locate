<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GeoLens Dark Globe</title>
    <style>
        body {
            margin: 0;
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #globeViz {
            width: 100vw;
            height: 100vh;
        }
        .tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            color: #ffffff;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 14px;
        }
        .tooltip-details {
            font-size: 11px;
            opacity: 0.8;
        }
        #loadingMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 16px;
            text-align: center;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loadingMessage">
        <div class="spinner"></div>
        <div>Initializing Globe...</div>
    </div>
    <div id="globeViz"></div>

    <!-- Three.js and Globe.GL - Try CDN first (online), fallback to local (offline) -->
    <script>
        // Configuration
        const config = {
            mode: 'auto', // 'online', 'offline', or 'auto'
            textureSource: 'auto' // CDN or local
        };

        // Check if running in offline mode
        function isOfflineMode() {
            return config.mode === 'offline' ||
                   (config.mode === 'auto' && !navigator.onLine);
        }

        // Load scripts dynamically based on mode
        function loadScript(src, fallbackSrc) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => {
                    if (fallbackSrc) {
                        console.log(`Failed to load ${src}, trying fallback ${fallbackSrc}`);
                        const fallbackScript = document.createElement('script');
                        fallbackScript.src = fallbackSrc;
                        fallbackScript.onload = resolve;
                        fallbackScript.onerror = reject;
                        document.head.appendChild(fallbackScript);
                    } else {
                        reject();
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Initialize globe after scripts load
        async function initGlobe() {
            try {
                // Load Three.js
                await loadScript(
                    'https://unpkg.com/three@0.150.0/build/three.min.js',
                    './lib/three.min.js' // Fallback to local
                );

                // Load Globe.GL
                await loadScript(
                    'https://unpkg.com/globe.gl@2.24.0/dist/globe.gl.min.js',
                    './lib/globe.gl.min.js' // Fallback to local
                );

                document.getElementById('loadingMessage').style.display = 'none';
                setupGlobe();
            } catch (error) {
                document.getElementById('loadingMessage').innerHTML =
                    '<div style="color: #ff6666;">Error loading globe libraries<br><small>' + error.message + '</small></div>';
            }
        }

        // Setup the globe
        function setupGlobe() {
            // Determine texture source
            const textureBase = isOfflineMode() ? './textures/' : 'https://unpkg.com/three-globe@2.24.0/example/img/';
            const earthTexture = textureBase + 'earth-night.jpg';
            const backgroundTexture = textureBase + 'night-sky.png';

            // Initialize globe
            window.globe = Globe()
                .globeImageUrl(earthTexture)
                .backgroundImageUrl(backgroundTexture)
                .atmosphereColor('#1a1a2e')
                .atmosphereAltitude(0.15)
                .showAtmosphere(true)
                .width(window.innerWidth)
                .height(window.innerHeight)
                (document.getElementById('globeViz'));

            // Configure controls
            globe.controls().autoRotate = false;
            globe.controls().enableDamping = true;
            globe.controls().dampingFactor = 0.1;
            globe.controls().rotateSpeed = 0.5;
            globe.controls().zoomSpeed = 0.8;
            globe.controls().minDistance = 150;
            globe.controls().maxDistance = 500;

            // Initial view
            globe.pointOfView({ lat: 0, lng: 0, altitude: 2.5 }, 0);

            // Handle window resize
            window.addEventListener('resize', () => {
                globe.width(window.innerWidth);
                globe.height(window.innerHeight);
            });

            // Data for pins
            window.pins = [];
            window.heatmapData = [];

            console.log('Globe initialized successfully');
        }

        // Add a pin to the globe
        function addPin(lat, lon, label, confidence, rank, isExif) {
            if (!window.globe) return;

            const color = isExif ? '#00ffff' : getConfidenceColor(confidence);
            const size = rank === 1 ? 1.0 : (rank <= 3 ? 0.7 : 0.5);
            const altitude = isExif ? 0.015 : (rank === 1 ? 0.012 : 0.008);

            window.pins.push({
                lat: lat,
                lng: lon,
                size: size,
                color: color,
                altitude: altitude,
                label: label,
                confidence: (confidence * 100).toFixed(1),
                rank: rank,
                isExif: isExif
            });

            updateGlobeData();
        }

        // Clear all pins
        function clearPins() {
            window.pins = [];
            updateGlobeData();
        }

        // Rotate to a specific location
        function rotateToLocation(lat, lon, duration) {
            if (!window.globe) return;

            const altitude = 2.0; // Zoom level
            globe.pointOfView({ lat: lat, lng: lon, altitude: altitude }, duration || 1000);
        }

        // Update globe with current pin data
        function updateGlobeData() {
            if (!window.globe || !window.pins) return;

            globe.pointsData(window.pins)
                .pointLat('lat')
                .pointLng('lng')
                .pointColor('color')
                .pointAltitude('altitude')
                .pointRadius('size')
                .pointLabel(d => `
                    <div class="tooltip">
                        <div class="tooltip-title">${d.isExif ? 'üìç EXIF GPS' : `#${d.rank} ${d.label}`}</div>
                        <div class="tooltip-details">
                            ${d.confidence}% confidence<br>
                            ${d.lat.toFixed(4)}¬∞, ${d.lng.toFixed(4)}¬∞
                        </div>
                    </div>
                `);
        }

        // Get color based on confidence
        function getConfidenceColor(confidence) {
            if (confidence >= 0.85) return '#00ff88'; // Cyan-Green (High)
            if (confidence >= 0.50) return '#ffdd00'; // Yellow (Medium)
            return '#ff6666'; // Red (Low)
        }

        // Enable/disable heatmap mode
        function setHeatmapMode(enabled) {
            // TODO: Implement heatmap visualization
            console.log('Heatmap mode:', enabled);
        }

        // Set globe mode (online/offline)
        function setGlobeMode(mode) {
            config.mode = mode;
            console.log('Globe mode set to:', mode);
        }

        // Expose API to C#
        window.globeAPI = {
            addPin: addPin,
            clearPins: clearPins,
            rotateToLocation: rotateToLocation,
            setHeatmapMode: setHeatmapMode,
            setGlobeMode: setGlobeMode,
            isReady: () => !!window.globe
        };

        // Start initialization
        initGlobe();
    </script>
</body>
</html>
